import { NextRequest, NextResponse } from "next/server";

interface ChartSpecification {
  chartType: "pie" | "line" | "bar";
  title: string;
  dataField: string;
  timeGrouping?: "daily" | "weekly" | "monthly" | "quarterly" | "yearly";
  aggregation: "sum" | "count" | "average" | "max" | "min";
  sortBy?: "value" | "label";
  sortOrder?: "asc" | "desc";
  limit?: number;
  filters?: {
    category?: string;
    dateRange?: string;
    valueThreshold?: number;
  };
  visualization: {
    size: "small" | "medium" | "large";
    colorScheme?: string;
    showTrend?: boolean;
    showGrid?: boolean;
    showTotal?: boolean;
    showPercentages?: boolean;
    orientation?: "horizontal" | "vertical";
    chartStyle?: "donut" | "standard";
  };
  insights: string;
}

const GEMINI_API_KEY = process.env.NEXT_GEMINI_KEY || process.env.GOOGLE_AI_API_KEY || process.env.GEMINI_API_KEY;

if (!GEMINI_API_KEY) {
  console.warn("GEMINI_API_KEY is not set in environment variables");
}

export async function POST(request: NextRequest) {
  try {
    const { userQuery, billingDataSample } = await request.json();

    if (!userQuery) {
      return NextResponse.json(
        { error: "User query is required" },
        { status: 400 }
      );
    }

    // If no Gemini API key, fall back to intelligent parsing
    if (!GEMINI_API_KEY) {
      console.log("No Gemini API key found, using fallback parsing");
      const fallbackSpec = parseUserQueryFallback(userQuery);
      return NextResponse.json({ chartSpec: fallbackSpec });
    }

    const prompt = `
You are an expert data visualization assistant. Analyze the user's request and generate a precise chart specification.

User Request: "${userQuery}"

Available Billing Data Fields:
- PatientID, PatientName, DateOfBirth, Gender, Address, PhoneNumber, Email
- InsuranceProvider, PolicyNumber, BillingNumber
- AdmissionDate, DischargeDate, ServiceDescription
- TotalCharges, InsuranceCoveragePercentage, AmountCoveredByInsurance
- AmountPaid, RunningBalance, PaymentStatus

Sample Data Context:
${billingDataSample ? JSON.stringify(billingDataSample.slice(0, 3)) : "No sample data provided"}

IMPORTANT KEYWORD MAPPINGS:
- "procedure", "service", "treatment", "medical service" → Use ServiceDescription as category
- "revenue", "charges", "money", "financial", "billing" → Use TotalCharges with sum aggregation
- "insurance", "provider", "coverage" → Use InsuranceProvider as category
- "payment status", "paid", "unpaid", "outstanding" → Use PaymentStatus as category
- "patient count", "number of patients" → Use PatientID with count aggregation

Generate a JSON response with the following structure:
{
  "chartType": "pie" | "line" | "bar",
  "title": "Descriptive chart title",
  "dataField": "Primary data field to analyze (e.g., TotalCharges, PatientID for counts)",
  "timeGrouping": "daily" | "weekly" | "monthly" | "quarterly" | "yearly" (only for time-based charts),
  "aggregation": "sum" | "count" | "average" | "max" | "min",
  "sortBy": "value" | "label",
  "sortOrder": "asc" | "desc",
  "limit": number (for top N items),
  "filters": {
    "category": "Field to group by (e.g., InsuranceProvider, ServiceDescription, PaymentStatus)",
    "dateRange": "Date filter if specified",
    "valueThreshold": "Minimum value threshold if specified"
  },
  "visualization": {
    "size": "small" | "medium" | "large",
    "colorScheme": "blue" | "green" | "red" | "purple" | "orange" | "professional" | "colorful" | "pastel",
    "showTrend": boolean,
    "showGrid": boolean,
    "showTotal": boolean,
    "showPercentages": boolean,
    "orientation": "horizontal" | "vertical",
    "chartStyle": "donut" | "standard"
  },
  "insights": "Brief explanation of what this chart will show"
}

Guidelines:
1. For revenue/financial queries, use TotalCharges field with sum aggregation
2. For patient counts, use PatientID field with count aggregation
3. For distributions, use pie charts with appropriate category grouping
4. For trends over time, use line charts with appropriate time grouping
5. For comparisons, use bar charts
6. Extract visual preferences (colors, size, style) from the user's language
7. Default to medium size and standard style unless specified
8. Provide meaningful chart titles and insights
9. PAY SPECIAL ATTENTION to procedure/service queries - they should ALWAYS use ServiceDescription as the category

EXAMPLES:
- "pie chart of revenue by procedure" → chartType: "pie", dataField: "TotalCharges", aggregation: "sum", filters.category: "ServiceDescription"
- "revenue generated by each procedure" → chartType: "pie", dataField: "TotalCharges", aggregation: "sum", filters.category: "ServiceDescription"
- "service breakdown" → chartType: "pie", dataField: "PatientID", aggregation: "count", filters.category: "ServiceDescription"

Respond only with valid JSON, no additional text.`;

    const response = await fetch(
      `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${GEMINI_API_KEY}`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          contents: [
            {
              parts: [
                {
                  text: prompt,
                },
              ],
            },
          ],
          generationConfig: {
            temperature: 0.1,
            topK: 1,
            topP: 1,
            maxOutputTokens: 2048,
          },
        }),
      }
    );

    if (!response.ok) {
      throw new Error(`Gemini API error: ${response.status}`);
    }

    const data = await response.json();
    const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;

    if (!generatedText) {
      throw new Error("No response from Gemini API");
    }

    // Parse the JSON response from Gemini
    let chartSpec: ChartSpecification;
    try {
      // Clean the response (remove markdown code blocks if present)
      const cleanedText = generatedText.replace(/```json\n?|\n?```/g, "").trim();
      chartSpec = JSON.parse(cleanedText);
    } catch {
      console.error("Failed to parse Gemini response:", generatedText);
      // Fall back to intelligent parsing
      chartSpec = parseUserQueryFallback(userQuery);
    }

    return NextResponse.json({ chartSpec });
  } catch (error) {
    console.error("Error in Gemini chart generation:", error);
    
    // Fall back to intelligent parsing
    const { userQuery } = await request.json();
    const fallbackSpec = parseUserQueryFallback(userQuery);
    
    return NextResponse.json({ chartSpec: fallbackSpec });
  }
}

// Fallback parsing function when Gemini is not available
function parseUserQueryFallback(userQuery: string): ChartSpecification {
  const query = userQuery.toLowerCase();
  
  // Determine chart type
  let chartType: "pie" | "line" | "bar" = "bar";
  if (query.includes("pie") || query.includes("distribution") || query.includes("breakdown")) {
    chartType = "pie";
  } else if (query.includes("line") || query.includes("trend") || query.includes("over time")) {
    chartType = "line";
  }
  
  // Determine data field and aggregation
  let dataField = "TotalCharges";
  let aggregation: "sum" | "count" | "average" | "max" | "min" = "sum";
  let category = "PaymentStatus";
  
  // Enhanced keyword detection for data fields
  if (query.includes("revenue") || query.includes("charges") || query.includes("money") || query.includes("financial") || query.includes("billing")) {
    dataField = "TotalCharges";
    aggregation = "sum";
  } else if (query.includes("patient") || query.includes("count") || query.includes("number of")) {
    dataField = "PatientID";
    aggregation = "count";
  } else if (query.includes("average") || query.includes("mean")) {
    dataField = "TotalCharges";
    aggregation = "average";
  }
  
  // Enhanced category detection with more keywords
  if (query.includes("procedure") || query.includes("service") || query.includes("treatment") || query.includes("medical service")) {
    category = "ServiceDescription";
  } else if (query.includes("insurance") || query.includes("provider") || query.includes("coverage")) {
    category = "InsuranceProvider";
  } else if (query.includes("gender") || query.includes("male") || query.includes("female")) {
    category = "Gender";
  } else if (query.includes("payment status") || query.includes("paid") || query.includes("unpaid") || query.includes("outstanding")) {
    category = "PaymentStatus";
  }
  
  // Determine time grouping
  let timeGrouping: "daily" | "weekly" | "monthly" | "quarterly" | "yearly" = "monthly";
  if (query.includes("daily")) timeGrouping = "daily";
  else if (query.includes("weekly")) timeGrouping = "weekly";
  else if (query.includes("quarterly")) timeGrouping = "quarterly";
  else if (query.includes("yearly")) timeGrouping = "yearly";
  
  // Determine visual preferences
  let size: "small" | "medium" | "large" = "medium";
  if (query.includes("large")) size = "large";
  else if (query.includes("small")) size = "small";
  
  let colorScheme: string | undefined;
  if (query.includes("blue")) colorScheme = "blue";
  else if (query.includes("green")) colorScheme = "green";
  else if (query.includes("red")) colorScheme = "red";
  else if (query.includes("professional")) colorScheme = "professional";
  else if (query.includes("colorful")) colorScheme = "colorful";
  
  // Extract limit
  const topMatch = query.match(/top (\d+)/);
  const limit = topMatch ? parseInt(topMatch[1]) : undefined;
  
  return {
    chartType,
    title: `${category} Analysis`,
    dataField,
    timeGrouping: chartType === "line" ? timeGrouping : undefined,
    aggregation,
    sortBy: "value",
    sortOrder: "desc",
    limit,
    filters: {
      category: chartType === "pie" ? category : undefined,
    },
    visualization: {
      size,
      colorScheme,
      showTrend: query.includes("trend"),
      showGrid: !query.includes("clean") && !query.includes("minimal"),
      showTotal: query.includes("total"),
      showPercentages: query.includes("percent"),
      orientation: query.includes("horizontal") ? "horizontal" : "vertical",
      chartStyle: query.includes("donut") ? "donut" : "standard",
    },
    insights: `This chart shows ${category.toLowerCase()} analysis based on your request.`,
  };
}